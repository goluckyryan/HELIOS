#include "HELIOS_LIB.h"
#include "TBenchmark.h"
#include "TLorentzVector.h"
#include "TMath.h"
#include "TFile.h"
#include "TTree.h"
#include "TRandom.h"
#include <vector>
#include <fstream>

void sim(){

   //================================================= Setting
   //---- reaction
   int AA = 208, zA = 82;
   int Aa = 2,  za = 1;
   int Ab = 1,  zb = 1;
   
   //---- beam
   double KEAmean = 15; // MeV/u 
   double KEAsigma = KEAmean*0.006; // MeV/u , assume Guassian
   double thetaMean = 0.; // mrad 
   double thetaSigma = 0.; // mrad , assume Guassian due to small angle
   
   int numEvent = 300000;
   
   //HELIOS detector geometry
   string heliosDetGeoFile = "detectorGeo_upstream.txt";
   double eSigma = 0.0001 ; // detector energy sigma MeV
   double xSigma = 0.1 ; // detector position sigma mm
   
   //---- excitation of Beam 
   double ExAList[2];
   ExAList[0] = 0.000; // MeV
   //ExAList[1] = 1.567;
    
   
   //---- excitation of recoil
   string excitationFile = "excitation_energies.txt";
   
   //---- save root file name
   TString saveFileName = "test_3.root";
   
   bool isTargetScattering = true;
   bool isDecay = false;
   bool isReDo = false; // redo calculation until detected. 
   
   //---- target
   double density = 0.913; // 0.913 g/cm3
   double targetThickness = 2.2e-4; // 2.2 um = 201 ug/cm2
   string stoppingPowerForA = "208Pb_in_CD2.txt"; // generated by SRIM
   string stoppingPowerForb = "1H_in_CD2.txt";
   string stoppingPowerForB = "209Pb_in_CD2.txt";
   
   //=============================================================
   //===== Set Reaction
   TransferReaction reaction;
  
   int AB = AA+Aa-Ab, zB = zA+za-zb;
   
   reaction.SetA(AA,zA);
   reaction.Seta(Aa,za);
   reaction.Setb(Ab,zb);
   reaction.SetB(AB,zB);
   
   reaction.SetIncidentEnergyAngle(12., 0, 0);
   reaction.CalReactioConstant();
   printf("===================================================\n");
   printf("=========== %s ===========\n", reaction.GetReactionName().Data());
   printf("=========== KE: %5.4f +- %5.4f MeV/u, dp/p = %5.2f \%\n", KEAmean, KEAsigma, KEAsigma/KEAmean * 50.);
   printf("=========== theta: %5.2f +- %5.2f MeV/u \n", thetaMean, thetaSigma);
   printf("=========== Q-value : %6.3f MeV, Max Ex: %6.3f MeV \n", reaction.GetQValue(), reaction.GetMaxExB());
   printf("===================================================\n");
   
   //-----loading excitation energy
   vector<double> ExKnown;
   printf("----- loading excitation energy levels.");
   ifstream file;
   file.open(excitationFile.c_str());
   string isotopeName;
   if( file.is_open() ){
      string line;
      int i = 0;
      while( file >> line){
         //printf("%d, %s \n", i,  line.c_str());
         if( line.substr(0,2) == "//" ) continue;
         if( i == 0 ) isotopeName = line; 
         if ( i >= 1 ){
            ExKnown.push_back(atof(line.c_str()));
         }
         i = i + 1;
      }
      file.close();
      printf("... done.\n");
      printf("========== %s\n", isotopeName.c_str());
      int n = ExKnown.size();
      for(int i = 0; i < n ; i++){
         printf("%d, %6.2f MeV \n", i, ExKnown[i]);
      }
       printf("===================\n");
   }else{
       printf("... fail\n");
   }
   
   //======== Set HELIOS   
   HELIOS helios;
   helios.SetDetectorGeometry(heliosDetGeoFile);
   
   //====================== build tree
   TFile * saveFile = new TFile(saveFileName, "recreate");
   TTree * tree = new TTree("tree", "tree");
   
   double thetaCM;
   double thetab, Tb;
   double thetaB, TB;
   
   int hit;
   double e, z, x, t, eLoss;
   int loop, detID;
   double dphi, rho;
   int ExID;
   double Ex, KEA, KEAnew, theta, phi;
   double ExA;
   int ExAID;

   double rhoHit, rhoBHit;
   double decayTheta;
   //double zzb[100], xb[100], yb[100];
   
   tree->Branch("hit", &hit, "hit/I");
   tree->Branch("thetab", &thetab, "thetab/D");
   tree->Branch("Tb", &Tb, "Tb/D");
   tree->Branch("thetaB", &thetaB, "thetaB/D");
   tree->Branch("TB", &TB, "Tb/D");
   tree->Branch("thetaCM", &thetaCM, "thetaCM/D");
   tree->Branch("e", &e, "e/D");
   tree->Branch("x", &x, "x/D");
   tree->Branch("z", &z, "z/D");
   tree->Branch("t", &t, "t/D");
   tree->Branch("eLoss", &eLoss, "eLoss/D");
   tree->Branch("detID", &detID, "detID/I");
   tree->Branch("loop", &loop, "loop/I");
   tree->Branch("dphi", &dphi, "dphi/D");
   tree->Branch("rho", &rho, "rho/D");
   tree->Branch("ExID", &ExID, "ExID/I");
   tree->Branch("Ex", &Ex, "Ex/D");
   tree->Branch("theta", &theta, "theta/D");
   tree->Branch("phi", &phi, "phi/D");
   tree->Branch("KEA", &KEA, "KEA/D");
   tree->Branch("KEAnew", &KEAnew, "KEAnew/D");
   tree->Branch("ExAID", &ExAID, "ExAID/I");
   tree->Branch("ExA", &ExA, "ExA/D");

   tree->Branch("rhoHit", &rhoHit, "rhoHit/D");
   tree->Branch("rhoBHit", &rhoBHit, "rhoBHit/D");
   tree->Branch("decayTheta", &decayTheta, "decayTheta/D");
   //tree->Branch("xb", xb, "xb[100]/D");
   //tree->Branch("yb", yb, "yb[100]/D");
   //tree->Branch("zb", zzb, "zb[100]/D");
   
   //==== Target scattering, only energy loss
   TargetScattering msA;
   TargetScattering msB;
   TargetScattering msb;

   printf("======== Target : (thickness : %6.2f um) x (density : %6.2f g/cm3) = %6.2f ug/cm2\n", 
                        targetThickness * 1e+4, 
                        density, 
                        targetThickness * density * 1e+6);  
            
   if( isTargetScattering ){
      msA.LoadStoppingPower(stoppingPowerForA);
      msb.LoadStoppingPower(stoppingPowerForb);
      msB.LoadStoppingPower(stoppingPowerForB);
   }
   
   //======= Decay of particle-B
   //TODO show which states will decay
   Decay decay;
   decay.SetMotherDaugther(AB, zB, AB-1,zB);
   
   //========timer
   TBenchmark clock;
   bool shown ;   
   clock.Reset();
   clock.Start("timer");
   shown = false;
   printf("================= generating %d events \n", numEvent);
   
   //====================================================== calculate 
   int count = 0;
   for( int i = 0; i < numEvent; i++){
      bool redoFlag = true;
      if( !isReDo ) redoFlag = false;
      do{
      
         //==== Set Ex of A
         ExAID = gRandom->Integer(2);
         ExA = ExAList[ExAID];
         reaction.SetExA(ExA);
         
         //==== Set Ex of B
         ExID = gRandom->Integer(ExKnown.size());
         Ex = ExKnown[ExID]; 
         reaction.SetExB(Ex);
         
         //==== Set incident beam
         if( KEAsigma == 0 ){
            KEA = KEAmean;
         }else{
            KEA = gRandom->Gaus(KEAmean, KEAsigma);
         }
         if( thetaSigma == 0 ){
            theta = thetaMean;
         }else{
            theta = gRandom->Gaus(thetaMean, thetaSigma);
         }
         phi = 0.;
         //phi = TMath::TwoPi() * gRandom->Rndm();
         reaction.SetIncidentEnergyAngle(KEA, theta, phi);
         reaction.CalReactioConstant();
         TLorentzVector PA = reaction.GetPA();            
         
         double depth = 0;
         if( isTargetScattering ){
            //==== Target scattering, only energy loss
            depth = targetThickness * gRandom->Rndm();
            msA.SetTarget(density, depth); 
            TLorentzVector PAnew = msA.Scattering(PA);
            KEAnew = msA.GetKE()/AA;
            reaction.SetIncidentEnergyAngle(KEAnew, theta, phi);
         }
         
         //==== Calculate reaction
         thetaCM = TMath::ACos(2 * gRandom->Rndm() - 1) ; 
         
         TLorentzVector * output = reaction.Event(thetaCM, 0);
      
         TLorentzVector Pb = output[2];
         TLorentzVector PB = output[3];
         
         if( isTargetScattering ){
            //==== Calculate energy loss of scattered and recoil in target
            msb.SetTarget(density, targetThickness - depth);
            Pb = msb.Scattering(Pb);
            eLoss = msb.GetKELoss();
            msB.SetTarget(density, targetThickness - depth);
            PB = msB.Scattering(PB);
         }else{
            eLoss = 0;
         }
         
         
         if( isDecay){
            //======= Decay of particle-B
            int isDecay = decay.CalDecay(PB, Ex, 0); // decay to ground state
            if( isDecay == 1 ){
               PB = decay.GetDaugther_D();
               decayTheta = decay.GetAngleChange();
            }else{
               decayTheta = TMath::QuietNaN();
            }
         }
         
         //------------- 
         thetab = Pb.Theta() * TMath::RadToDeg();
         thetaB = PB.Theta() * TMath::RadToDeg();
      
         Tb = Pb.E() - Pb.M();
         TB = PB.E() - PB.M();
         
         
         //==== Helios
         hit = helios.CalHit(Pb, zb, PB, zB);
         
         e = helios.GetEnergy() + gRandom->Gaus(0, eSigma);
         z = helios.GetZ() + gRandom->Gaus(0, xSigma);
         x = helios.GetX() + gRandom->Gaus(0, xSigma);
         t = helios.GetTime();
         loop = helios.GetLoop();
         detID = helios.GetDetID();
         dphi = helios.GetdPhi();
         rho = helios.GetRho();
         rhoHit = helios.GetRhoHit();
         rhoBHit = helios.GetRecoilRhoHit();
         /*
         for(int i = 0; i < 100 ; i++){
            double theta = Pb.Theta();
            zzb[i] = z/100.*( i + gRandom->Rndm() - 0.5 );
            xb[i] = rho * (1- TMath::Cos( TMath::Tan(theta) * zzb[i]/rho) );
            yb[i] = rho * TMath::Sin( TMath::Tan(theta) * zzb[i]/rho);
         }
         */
         
         if( isReDo ){
            if( hit == 1) {
               count ++;   
               redoFlag = false;
            }else{
               redoFlag = true;
               //printf("%d, %2d, thetaCM : %f, theta : %f, z0: %f \n", i, hit, thetaCM * TMath::RadToDeg(), thetab, helios.GetZ0());
            }
         }else{
            redoFlag = false;
         }
         
      }while( redoFlag );
      tree->Fill();
      
      //#################################################################### Timer  
      clock.Stop("timer");
      Double_t time = clock.GetRealTime("timer");
      clock.Start("timer");
      
      if ( !shown ) {
         if (fmod(time, 10) < 1 ){
            printf( "%10d[%2d%%]| %8.2f sec | expect: %5.1f min \n", i, TMath::Nint((i+1)*100./numEvent), time , numEvent*time/(i+1)/60);
            shown = 1;
         }
      }else{
         if (fmod(time, 10) > 9 ){
            shown = 0;
         }
      }
   }
   
   saveFile->Write();
   saveFile->Close();
   
   printf("=============== done. saved as %s.\n", saveFileName.Data());

}
